@typeparam TItem
@inject DragDropService dragDropService
@implements IDisposable
@implements IDragDropZone

<div class=@getClasses() @ondragover:preventDefault ondragend="@dragDropService.StopDrag" ondragover="@(() => {dragDropService.SetOver(this); if (emptyAndHovering) {StateHasChanged();}})" ondragenter="" ondragleave="@(() => {currentHoverIndex = -1;})">
    
    @if (DropOnly)
    {
        <div class="dropZoneOnly">
            <h1>@Name</h1>
        </div>
    }
    else
    {
        int i = 0;
        if (emptyAndHovering)
        {
            <div class="dropOutline">
            </div>
        }

        while (i < Items.Count)
        {
            object item = Items[i];
            int index = i;
            <div ondragover="@(() => DragOverItem(index))">
                <div draggable="true" @ondragover:preventDefault ondragstart="@(() => dragDropService.StartDrag(this, item))">
                    @ItemRenderer((TItem)item)
                </div>

                @if (i == currentHoverIndex)
                {
                    <div class="dropOutline">
                    </div>
                }
            </div>

            i++;
        }
    }
</div>

@code {
    [Parameter]
    public RenderFragment<TItem> ItemRenderer { get; set; }

    [Parameter]
    public bool DropOnly { get; set; } = false;

    [Parameter]
    public string Name { get; set; }

    [Parameter]
    public string CanDropClass { get; set; } = "";

    [Parameter]
    public string NoDropClass { get; set; } = "";

    private List<object> Items { get; set; } = new();

    private int currentHoverIndex = -1;

    private bool emptyAndHovering => Items.Count == 0 && dragDropService.CanDropHere(this);

    public override string ToString()
    {
        return Name;
    }

    protected override void OnInitialized()
    {
        dragDropService.AddZone(this);
        base.OnInitialized();
    }

    public void Dispose()
    {
        dragDropService.RemoveZone(this);
    }

    // TODO: CHECK for interfaces and other types?
    public bool CanDropItem(object item) => typeof(TItem).IsCompatibleType(item.GetType());

    public void DropItem(object item)
    {
        if (CanDropItem(item))
        {
            int insertIndex = currentHoverIndex == -1 ? Items.Count : currentHoverIndex + 1;
            Items.Insert(insertIndex, item);
            StateHasChanged();
        }
    }

    public void RemoveItem(object item)
    {
        this.Items.Remove(item);
        StateHasChanged();
    }

    private string getClasses()
    {
        List<string> classes = new() { "dropZone" };

        bool isCurrent = dragDropService.IsCurrent(this);
        bool isValid = dragDropService.CanDropHere(this);

        if (isCurrent && isValid)
        {
            classes.Add(CanDropClass);
        } 
        else if (isCurrent)
        {
            classes.Add(NoDropClass);
        }

        return String.Join(" ", classes.ToArray());
    }

    private void DragOverItem(int index)
    {
        if (dragDropService.CanDropHere(this))
        {
            currentHoverIndex = index;
        }
        StateHasChanged();
    }

    public void UpdateCurrentZone(bool isCurrent)
    {
        if (!isCurrent)
        {
            currentHoverIndex = -1;
        }
        StateHasChanged();
    }
}
