@typeparam TItem
@inject DragDropService dragDropService
@implements IDisposable
@implements IDragDropZone

<!--Make styling more simple? Maybe update styling when checking ondragover?-->
<div class=@getClasses() @ondragover:preventDefault ondragend="@dragDropService.StopDrag" ondragover="@(() => {dragDropService.SetOver(this); if (emptyAndHovering) {StateHasChanged();}})" ondragenter="" ondragleave="@(() => {currentHoverIndex = -1;})">
    @{int i = 0;}
    @if (emptyAndHovering)
    {
        <div style="border-width: 1px; border-style: dashed; border-color:green; padding: 2px; height: 100px;">
        </div>
    }

    @while (i < Items.Count)
    {
        object item = Items[i];
        int index = i;
        <div ondragover="@(() => DragOverItem(index))">
            <div draggable="true" @ondragover:preventDefault ondragstart="@(() => dragDropService.StartDrag(this, item))">
                @ItemRenderer((TItem)item)
            </div>

            @if (i == currentHoverIndex)
            {
                <div style="border-width: 1px; border-style: dashed; border-color:green; padding: 2px; height: 100px">
                </div>
            }
        </div>

        i++;
    }
</div>

@code {
    [Parameter]
    public RenderFragment<TItem> ItemRenderer { get; set; }

    [Parameter]
    public string Name { get; set; }

    private List<object> Items { get; set; } = new();

    private int currentHoverIndex = -1;

    private bool emptyAndHovering => Items.Count == 0 && dragDropService.CanDropHere(this);

    public override string ToString()
    {
        return Name;
    }

    protected override void OnInitialized()
    {
        dragDropService.AddZone(this);
        base.OnInitialized();
    }

    public void Dispose()
    {
        dragDropService.RemoveZone(this);
    }

    // TODO: CHECK for interfaces and other types?
    public bool CanDropItem(object item) => item.GetType().IsSameOrSubClassOf(typeof(TItem));

    public void DropItem(object item)
    {
        if (item.GetType().IsSameOrSubClassOf(typeof(TItem)))
        {
            int insertIndex = currentHoverIndex == -1 ? Items.Count : currentHoverIndex + 1;
            Items.Insert(insertIndex, item);
            StateHasChanged();
        }
    }

    public void RemoveItem(object item)
    {
        this.Items.Remove(item);
        StateHasChanged();
    }

    private string getClasses()
    {
        List<string> classes = new() { "dropZone" };

        bool isCurrent = dragDropService.IsCurrent(this);
        bool isValid = dragDropService.CanDropHere(this);

        if (isCurrent && isValid)
        {
            classes.Add("drop");
        } 
        else if (isCurrent)
        {
            classes.Add("noDrop");
        }

        return String.Join(" ", classes.ToArray());
    }

    private void DragOverItem(int index)
    {
        if (dragDropService.CanDropHere(this))
        {
            currentHoverIndex = index;
        }
        StateHasChanged();
    }

    public void UpdateCurrentZone(bool isCurrent)
    {
        if (!isCurrent)
        {
            currentHoverIndex = -1;
        }
        StateHasChanged();
    }
}
